/** @file java.h
    @brief JNI wrapper.

    The JNI wrapper provides several functions that simplify Java virtual
    machine creation and destruction, thread management, string conversion,
    exception handling, and method calls. Typical usage of the JNI wrapper by a
    thread appears like this:

    <pre>
    if(!java_attach())
        Handle the error - usually non-recoverable.

    jobject java_string = java_encode(some_source_string);
    if(jobject == NULL)
        Handle the failure to convert buffer to byte array.

    jobject file;
    jobject exception;
    bool    result = java_call("someMethod", "([B)Ljava/io/File;",
                               file, exception, java_string);
    if(exception != NULL)
        Handle the exception.
    if(!result)
        Handle the call failure.

    Do something with file.

    java_detach();
    </pre>

    The two <code>java_call</code> methods require the user to specify the
    signature of the method to be called. Information on method signatures can
    be found in the JNI 1.6 specification, chapter 3, section "Type Signatures":

  http://download.oracle.com/javase/6/docs/technotes/guides/jni/spec/jniTOC.html

    This JNI wrapper is only capable of performing calls to static methods of
    the class <code>fuse.Fuse</code>.

    The native types representing Java objects are in fact pointers to
    JNI-managed storage for those objects. Two things follow from this. First,
    when the documentation in this file mentions setting a C++ reference to a
    Java object, it is in fact referring to copying a single pointer. Second,
    these pointers may be set to <code>NULL</code> to indicate error conditions,
    or lack of a suitable object (for example, if no exception is generated by a
    call).
 */

#ifndef _JAVA_H_
#define _JAVA_H_

/** @name Initialization and Cleanup */
//@{
/** @brief Initializes the Java virtual machine.

    Care should be taken when using this function. The FUSE library performs a
    <code>fork</code> (actually <code>daemon</code>) operation during startup.
    This function should be called from within the process that is the FUSE
    daemon, after the <code>fork</code> operation. Failure to do so may result
    in unpredictable behavior by the Java virtual machine, depending on its
    implementation.

    After initialization, the current thread is not attached to the virtual
    machine. The current thread must re-attach itself to the virtual machine to
    perform Java operations.

    Initialization is a two-step process. After the virtual machine itself is
    initialized, the user should call <code>java_load_classes</code> to define
    the driver classes for the virtual machine. The reason this is done in a
    separate step is that after the virtual machine is certain to have been
    initialized successfully, it is safe and reasonable to return Java exception
    objects from the <code>java_load_classes</code> method that can then be
    logged, if necessary, using <code>java_describe_exception</code>. If
    initialization is performed in a single step, it is not clear to the caller,
    when initialization fails, whether it is safe to use a Java exception object
    in this manner.

    @return <code>true</code> if initialization succeeds, and <code>false</code>
            otherwise. Initialization fails if a Java 1.6 virtual machine cannot
            be created.
 */
bool java_initialize(void);

/** @brief Causes the virtual machine to load Java classes stored in the program
           image.

    To avoid the need to distribute a <code>.jar</code> file or a directory tree
    with several <code>.class</code> files together with the native portion of
    the FUSE driver, the Java classes necessary for the FUSE driver are stored
    inline in the native program image. They are therefore available in memory
    by the time the image has been loaded and the driver started.

    This function commands the virtual machine to load these classes. After
    this, the native code may freely call any of the Java code in the classes.

    The classes that are loaded are those listed in the table found in the
    generated file <code>java-classes.c</code>. The table itself is declared in
    the file <code>java-classes.h</code>. <code>java-classes.c</code> is
    typically generated by running the Java program
    <code>build.MakeClassesImage</code> with the appropriate arguments from the
    <code>Makefile</code>.

    @return <code>NULL</code> if the classes are loaded successfully. If there
            is an error, a Java exception object descriptive of the error is
            returned instead.
 */
jthrowable java_load_classes(void);

/** @brief Destroys the Java virtual machine.

    The current thread need not be attached to the virtual machine to call this
    function.
 */
void java_destroy(void);
//@}

/** @name Thread Management */
//@{
/** @brief Attaches the current thread to the Java virtual machine.

    This function must be called before a thread performs any JNI operations.

    @return <code>true</code> if the thread is successfully attached to the
            virtual machine, <code>false</code> otherwise.
 */
bool java_attach(void);

/** @brief Detaches the current thread from the Java virtual machine.

    Each thread must call this function when it is finished performing JNI
    operations. Failure to call this function will likely lead to memory leaks
    when the Java garbage collector does not release local references held by
    the thread.
 */
void java_detach(void);
//@}

/** @name Exception Handling */
//@{
/** @brief Translates a Java exception object to a suitable POSIX error code.

    The translation is currently defined as follows:

    - <code>IllegalArgumentException</code> is translated to
      <code>EINVAL</code>.
    - <code>IndexOutOfBoundsException</code> is translated to
      <code>EINVAL</code>.
    - <code>FileNotFoundException</code> is translated to <code>ENOENT</code>.

    All other exceptions are translated to <code>EIO</code>.

    @param exception Exception to be translated.
    @return Resulting POSIX error code. The default POSIX error code
            <code>EIO</code> is also returned if this function fails.
 */
int java_error_code(jthrowable exception);

/** @brief Logs a description of a Java exception.

    This function is not thread safe. If it is necessary to take a lock to
    prevent other threads from interfering with logging, then the caller must
    take the lock before calling this function.

    @param exception Exception to be logged.
    @param filename Path to the log file. The filename must be encoded in the
                    system's default encoding, as that term is understood by
                    the system's Java virtual machine.
    @param stack_trace If <code>true</code>, the complete stack trace associated
                       with the exception is written to the log file. Otherwise,
                       the message printed is the same as the result of calling
                       the exception's <code>toString</code> method.
 */
void java_describe_exception(jthrowable exception, const char *filename,
                             bool stack_trace);
//@}

/** @name Strings and Buffers */
//@{
/** @brief Converts a regular C++ buffer to a Java byte array.

    @param buffer Buffer to be converted.
    @param length Size of the buffer to be converted.
    @return A Java byte array containing a copy of the data in the buffer.
            <code>NULL</code> is returned if the operation fails.
 */
jobject java_encode(const char *buffer, size_t length);

/** @brief Converts a null-terminated string to a Java byte array.

    The null terminator is not included in the resulting byte array. No decoding
    or encoding operations are performed on the characters of the string - the
    bytes of the string are converted directly as they are, until the null
    terminator, which is dropped. This is suitable for strings passed to FUSE,
    as the kernel guarantees the absence of embedded zero bytes in paths.

    @param string String to be converted.
    @return A Java byte array containing a copy of the bytes in the string, less
            the null terminator. <code>NULL</code> is returned if the operation
            fails.
 */
jobject java_encode(const char *string);

/** @brief Extracts bytes from a Java byte array into a regular C++ buffer.

    Note that this function assumes that <code>buffer</code> is a pointer to
    sufficient storage for the contents of the entire Java array. The caller
    must ensure that sufficient storage is available.

    @param byte_array The Java byte array.
    @param length Reference to a variable of type <code>size_t</code> that will
                  be filled with the number of bytes extracted.
    @param buffer Buffer to receive the bytes extracted.
    @return <code>true</code> if the bytes are extracted from the array
            successfully, <code>false</code> otherwise.
 */
bool java_decode(jobject byte_array, size_t &length, char *buffer);

/** @brief Converts a Java byte array to a newly-allocated regular C++ buffer.

    The caller must release the buffer that is returned using the operator
    <code>delete[]</code> when the buffer is no longer needed.

    @param byte_array The Java byte array.
    @param length Reference to a variable of type <code>size_t</code> that will
                  be filled with the size of the byte array (and the length of
                  the new buffer).
    @return A buffer containing a copy of the contents of the Java byte array,
            or <code>NULL</code> if the operation fails.
 */
char* java_decode(jobject byte_array, size_t &length);
//@}

/** @name Method Calls */
//@{
/** @brief Calls a static <code>void</code> method in the Java class
           <code>fuse.Fuse</code>.

    @param method Method name.
    @param signature Method signature. See the JNI reference for a description
                     of method signatures.
    @param exception Reference to a location that will be filled with a Java
                     exception object if an exception occurs while attempting to
                     call the method, or while executing the method body. If no
                     exception occurs, the referent is set to <code>NULL</code>.
    @param ... Arguments to be passed to the method.
    @return <code>true</code> if the method was found and called,
            <code>false</code> otherwise. In most cases where the method cannot
            be called, an exception is generated, and can be retrieved through
            the referent of <code>exception</code>. Note that the referent
            might be non-<code>NULL</code> no matter what this function returns.
            It is preferable to check whether there has been an exception before
            checking the return value.

 */
bool java_call(const char *method, const char *signature, jthrowable &exception,
               ...);

/** @brief Calls a static non-<code>void</code> method in the Java class
           <code>fuse.Fuse</code>.

    @tparam JavaType Return type of the Java method. In principle, this could be
                     any one of <code>jboolean</code>, <code>jchar</code>,
                     <code>jbyte</code>, <code>jshort</code>, <code>jint</code>,
                     <code>jlong</code>, <code>jfloat</code>,
                     <code>jdouble</code>, or <code>jobject</code>. However,
                     currently, the template is only instantiated for
                     <code>jboolean</code>, <code>jlong</code>, and
                     <code>jobject</code>. Explicit instantiation of the
                     template in <code>java.cpp</code> is necessary to call this
                     method at other Java types.
    @param method Method name.
    @param signature Method signature. See the JNI reference for a description
                     of method signatures.
    @param result Reference to a location that will be filled with the result of
                  the method call, if the method call is successful and an
                  exception does not occur.
    @param exception Reference to a location that will be filled with a Java
                     exception object if an exception occurs while attempting to
                     call the method, or while executing the method body. If no
                     exception occurs, the referent is set to <code>NULL</code>.
    @param ... Arguments to be passed to the method.
    @return <code>true</code> if the method was found and called,
            <code>false</code> otherwise. In most cases where the method cannot
            be called, an exception is generated, and can be retrieved through
            the referent of <code>exception</code>. Note that the referent
            might be non-<code>NULL</code> no matter what this function returns.
            It is preferable to check whether there has been an exception before
            checking the return value.
 */
template <typename JavaType>
    bool java_call(const char *method, const char *signature, JavaType &result,
                   jthrowable &exception, ...);
//@}

#endif // #ifndef _JAVA_H_
